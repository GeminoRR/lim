/////////////////////////
/////// INT CLASS ///////
/////////////////////////
primary class int
	//Propreties
	$"Public value As Integer = 0"

	//New
	$"Public Sub New(ByVal value As Integer)"
	$"	Me.value = value"
	$"End Sub"

	//Str
	func __str__:str
		$"Return New str(Me.value.ToString())"

	//Float
	func __float__:float
		$"Return New float(Me.value)"

	//Add relation
	relation +(n1:int, n2:int):int
		$"Return New int(n1.value + n2.value)"
	relation +(n1:int, n2:float):float
		$"Return New float(n1.value + n2.value)"

	//Minus relation
	relation -(n1:int, n2:int):int
		$"Return New int(n1.value - n2.value)"
	relation -(n1:int, n2:float):float
		$"Return New float(n1.value + n2.value)"

	//Multiplication
	relation *(n1:int, n2:int):int
		$"Return New int(n1.value * n2.value)"
	relation *(n1:int, n2:float):float
		$"Return New float(n1.value * n2.value)"
	relation *(n1:int, n2:str):str
		$'Dim temp As String = ""'
		$"For i As Integer = 0 To n1.value - 1"
		$"	temp &= n2.value"
		$"Next"
		$"Return New str(temp)"

	//Division
	relation /(n1:int, n2:int):float
		$"Return New float(n1.value / n2.value)"
	relation /(n1:int, n2:float):float
		$"Return New float(n1.value / n2.value)"

	//Modulo
	relation %(n1:int, n2:int):int
		$"Return New int(n1.value Mod n2.value)"
	relation %(n1:int, n2:float):float
		$"Return New float(n1.value Mod n2.value)"

///////////////////////////
/////// FLOAT CLASS ///////
///////////////////////////
primary class float
	//Propreties
	$"Public value As Double = 0.0"

	//New
	$"Public Sub New(ByVal value As Double)"
	$"	Me.value = value"
	$"End Sub"

	//Str
	func __str__:str
		$"Return New str(Me.value.ToString())"

	//Int
	func __int__:int
		$"Return New int(Math.Round(Me.value))"

	//Round
	func round(var count:int = 0):float
		$"Return New float(Math.Round(Me.value, count.value))"

	//Add relation
	relation +(n1:float, n2:float):float
		$"Return New float(n1.value + n2.value)"
	relation +(n1:float, n2:int):float
		$"Return New float(n1.value + n2.value)"

	//Minus relation
	relation -(n1:float, n2:int):float
		$"Return New float(n1.value - n2.value)"
	relation -(n1:float, n2:float):float
		$"Return New float(n1.value + n2.value)"

	//Multiplication
	relation *(n1:float, n2:int):float
		$"Return New float(n1.value * n2.value)"
	relation *(n1:float, n2:float):float
		$"Return New float(n1.value * n2.value)"

	//Division
	relation /(n1:float, n2:int):float
		$"Return New float(n1.value / n2.value)"
	relation /(n1:float, n2:float):float
		$"Return New float(n1.value / n2.value)"

	//Modulo
	relation %(n1:float, n2:int):float
		$"Return New float(n1.value Mod n2.value)"
	relation %(n1:float, n2:float):float
		$"Return New float(n1.value Mod n2.value)"

//////////////////////////
/////// BOOL CLASS ///////
//////////////////////////
primary class bool
	//Propreties
	$"Public value As Boolean = True"

	//New
	$"Public Sub New(ByVal value As Boolean)"
	$"	Me.value = value"
	$"End Sub"

	//Str
	func __str__:str
		$"Return New str(Me.value.ToString())"

/////////////////////////
/////// STR CLASS ///////
/////////////////////////
primary class str
	//Propreties
	$'Public value As String = ""'

	//New
	$"Public Sub New(ByVal value As String)"
	$"	Me.value = value"
	$"End Sub"

	//Str
	func __str__:str
		$"Return Me"

	//Int
	func __int__:int
		$"Try"
		$"    Return New int(Convert.ToInt32(Me.value))"
		$"Catch ex As Exception"
		$"    Return Nothing"
		$"End Try"

	//Boolean
	func __bool__:bool
		$"If Me.value = 1 Then"
		$"	Return new bool(True)"
		$"End If"
		$"Return new bool(False)"

	//Float
	func __float__:float
		$"Try"
		$"    Return New float(Convert.ToDouble(Me.value))"
		$"Catch ex As Exception"
		$"    Return Nothing"
		$"End Try"

	//Substring
	func substring(positionStart:int, length:int):str
		//Check if position start is in string
		$"If Not (positionStart.value >= 0 And positionStart.value < Me.value.Length) Then"
		$"	Return Nothing"
		$"End If"

		//Substring
		$"If length.value = -1"
		$"	Return New str(Me.value.Substring(positionStart.value))"
		$"Else"
		$"	If Not (positionStart.value + length.value <= Me.value.Length) Then"
		$"		Return Nothing"
		$"	End If"
		$"	Return New str(Me.value.Substring(positionStart.value, length.value))"
		$"End If"

	//Len
	func len:int
		$"Return New int(Me.value.Length)"

	//Lower
	func lower():str
		$"Return New str(Me.value.ToLower())"

	//Upper
	func upper():str
		$"Return New str(Me.value.ToUpper())"

	//Add relation
	relation +(n1:str, n2:str):str
		$"Return New str(n1.value + n2.value)"
	
	//Multiplication
	relation *(n1:str, n2:int):str
		$'Dim temp As String = ""'
		$"For i As Integer = 0 To n2.value - 1"
		$"	temp &= n1.value"
		$"Next"
		$"Return New str(temp)"

/////////////////////////
/////// FUN CLASS ///////
/////////////////////////
primary class fun
	//Propreties
	$"Public value As Integer = -1"

	//New
	$"Public Sub New(ByVal value As Integer)"
	$"	Me.value = value"
	$"End Sub"

	//Str
	func __str__:str
		$"Return New str(Me.value.ToString())"

/////////////////////////
/////// IO - PUTS ///////
/////////////////////////
func puts(message:str)
	$'Console.WriteLine(message.value)'

/////////////////////////
/////// IO - GETS ///////
/////////////////////////
func gets(message:str):str
	$"Console.Write(message.value)"
	$"Return New str(Console.ReadLine())"

/////////////////////
/////// RANGE ///////
/////////////////////
func range(min:int, max:int = -1):int[]
	$"If max.value = -1 Then"
	$"	max.value = min.value"
	$"	min.value = 0"
	$"End If"
	$"Dim temp As New LimList(Of int)"
	$"For i As Integer = min.value To max.value - 1"
	$"	temp.add(new int(i))"
	$"Next"
	$"Return temp"