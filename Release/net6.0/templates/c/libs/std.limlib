/////////////////////
//////// INT ////////
/////////////////////
//Class
export primary class __int__
	//Properties
	$"int value;"

	//Clone
	func clone:int
		$"//Create new object"
		$"__int__ * clone = tgc_alloc(&gc, sizeof(__int__));"
		$""
		$"//Copy value"
		$"clone->value = self->value;"
		$""
		$"//Return"
		$"return clone;"

	//Str
	func str:str
		$"//Create result"
		$"char * result = tgc_alloc(&gc, sizeof(char) * 20);"
		$'sprintf(result, "%i", self->value);'
		$"return new_str(result);"

	//Repr
	func repr:str
		$"return {{self}}_str(self);"

	//Relation
	relation +(num1:int, num2:int):int
		$"return new_int(num1->value + num2->value)"

//Creator
func $"new_int(int value)":int
	$"__int__ * temp = __int___new();"
	$"temp->value = value;"
	$"return temp;"

///////////////////////
//////// FLOAT ////////
///////////////////////
export primary class __float__
	//Properties
	$"double value;"

	//Clone
	func clone:float
		$"//Create new object"
		$"__float__ * clone = tgc_alloc(&gc, sizeof(__float__));"
		$""
		$"//Copy value"
		$"clone->value = self->value;"
		$""
		$"//Return"
		$"return clone;"

	//Str
	func str:str
		$"//Create result"
		$"char * result = tgc_alloc(&gc, sizeof(char) * 20);"
		$'sprintf(result, "%lf", self->value);'
		$"return new_str(result);"

	//Repr
	func repr:str
		$"return {{self}}_str(self);"

//Creator
func $"new_float(float value)":float
	$"__float__ * temp = __float___new();"
	$"temp->value = value;"
	$"return temp;"

/////////////////////
//////// STR ////////
/////////////////////
export primary class __str__
	//Properties
	$"char * value;"

	//Clone
	func clone:str
		$"//Create new object"
		$"__str__ * clone = tgc_alloc(&gc, sizeof(__str__));"
		$""
		$"//Copy value"
		$"clone->value = tgc_alloc(&gc, sizeof(char) * strlen(self->value) + 1);"
		$"strcpy(clone->value, self->value);"
		$""
		$"//Return"
		$"return clone;"

	//Str
	func str:str
		$"//Return"
		$"return self;"

	//Repr
	func repr:str
		$"//Create string"
		$"char * temp = tgc_alloc(&gc, sizeof(char) * (strlen(self->value) + 3));"
		$'sprintf(temp, "\"%s\"", self->value);'
		$""
		$"//Return"
		$"return new_str(temp);"

//Creator
func $"new_str(char * value)":str
	$"__str__ * temp = __str___new();"
	$"temp->value = tgc_alloc(&gc, sizeof(char) * strlen(value) + 1);"
	$"strcpy(temp->value, value);"
	$"return temp;"

//////////////////////
//////// BOOL ////////
//////////////////////
export primary class __bool__
	//Properties
	$"bool value;"

	//Clone
	func clone:bool
		$"//Create new object"
		$"__bool__ * clone = tgc_alloc(&gc, sizeof(__bool__));"
		$""
		$"//Copy value"
		$"clone->value = self->value;"
		$""
		$"//Return"
		$"return clone;"

	//Str
	func str:str
		$"//Condition"
		$"if (self->value){"
		$'	return new_str("True");'
		$"} else {"
		$'	return new_str("False");'
		$"}"
		
	//Repr
	func repr:str
		$"return {{self}}_str(self);"

//Creator
func $"new_bool(bool value)":bool
	$"__bool__ * temp = __bool___new();"
	$"temp->value = value;"
	$"return temp;"

////////////////////
/////// LIST ///////
////////////////////
export class list<item_type>
	//Content of the struct
	$"{{item_type}} ** array;"
	$"size_t used;"
	$"size_t size;"

	//New
	func new
		$"self->array = tgc_alloc(&gc, (5 * sizeof({{self}})));"
		$"self->used = 0;"
		$"self->size = 5;"
		$"return self;"

	//Add (insert last)
	func add(elm:item_type)
		$"if (self->used == self->size) {"
		$"	self->size *= 2;"
		$"	self->array = tgc_realloc(&gc, self->array, self->size * sizeof({{self}}));"
		$"}"
		$"self->array[self->used++] = elm;"

	//Str
	func str:str
		$"char * result = malloc(sizeof(char) * 2);"
		$'strcpy(result, "[");'
		$"bool first_object = true;"
		$"for (int i = 0; i < self->used; i++){"
		$"	char * elm_str = ({{item_type}}_repr(self->array[i]))->value;"
		$"	char * temp = malloc(sizeof(char) * (strlen(result) + strlen(elm_str) + 3));"
		$"	if (first_object)"
		$'		sprintf(temp, "%s%s", result, elm_str);'
		$"	else"
		$'		sprintf(temp, "%s, %s", result, elm_str);'
		$"first_object = false;"
		$"result = temp;"
		$"}"
		$"char * final = malloc(sizeof(char) * (strlen(result) + 2));"
		$'sprintf(final, "%s]", result);'
		$"return new_str(final);"

/////////////////////////////
//////// LINKED LIST ////////
/////////////////////////////
export class linkedlist<item_type>
	$"{{self}} * next;"
	$"{{item_type}} * item;"

	//New
	func new
		$""
		$"self->item = NULL;"
		$"self->next = NULL;"

	//Add
	func add(elm:item_type)
		$""
		$"//Create new node"
		$"{{self}} * newNode = tgc_alloc(&gc, sizeof({{self}}));"
		$""
		$"//Link data"
		$"newNode->item = {{elm}};"
		$""
		$"//Set next"
		$"newNode->next = NULL;"
		$""
		$"//Add to end of list"
		$"{{self}} * temp = self;"
		$"while (temp->next != NULL){"
		$"	temp = temp->next;"
		$"}"
		$""
		$"temp->next = newNode;"

	//Lenght
	func len:int
		$""
		$"//Go through the whole list"
		$"{{self}} * temp = self;"
		$"int count = 0;"
		$"while (temp->next != NULL){"
		$"	temp = temp->next;"
		$"	count++;"
		$"}"
		$""
		$"//Return"
		$"return new_int(count);"

	//Str
	func str:str
		$""
		$'char * result = tgc_alloc(&gc, sizeof(char) + 1);'
		$'strcpy(result, "[");'
		$"{{self}} * temp = self->next;"
		$"bool add_separator = false;"
		$"while(temp != NULL) {"
		$"	char * item_str = ({{item_type}}_repr(temp->item))->value;"
		$"	char * new_result = tgc_alloc(&gc, strlen(result) + strlen(item_str) + 3);"
		$"	strcpy(new_result, result);"
		$"	tgc_free(&gc, result);"
		$"	if (add_separator){"
		$'		strcat(new_result, ", ");'
		$"	}"
		$"	strcat(new_result, item_str);"
		$"	result = new_result;"
		$"	temp = temp->next;"
		$"	add_separator = true;"
		$"}"
		$"char * final = tgc_alloc(&gc, strlen(result) + 2);"
		$"strcpy(final, result);"
		$"tgc_free(&gc, result);"
		$'strcat(final, "]");'
		$"return new_str(final);"

/////////////////////
//////// MAP ////////
/////////////////////
export class map<key_type, value_type>
	let keys:list<key_type>
	let values:list<value_type>

////////////////////
//////// IO ////////
////////////////////

//Puts (print to the standard output)
export func __puts__(value:str)
	$'printf("%s\n", value->value);'

//Gets (input from the standart terminal)
export func __gets__(value:str):str
	$'printf("%s", value->value);'
	$"char * buffer = tgc_alloc(&gc, sizeof(char) * 999);"
	$"if (fgets(buffer, 998, stdin) != 0){"
	$'	buffer[strlen(buffer) - 1 ] = "\0";'
	$"	return new_str(buffer);"
	$"}"
	$'return new_str("");'

/////////////////////
//////// CMD ////////
/////////////////////

///////////////////////////////
//////// RUNTIME ERROR ////////
///////////////////////////////
func $"fatalError(const char * message)"
	$'printf("FATAL RUNTIME ERROR: %s\n", message);'
	$"exit(-1);"